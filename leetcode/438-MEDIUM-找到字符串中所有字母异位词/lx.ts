export function findAnagrams(s: string, p: string): number[] {
  const res: number[] = []
  const sp = sortStr(p)
  for (let i = 0; i < s.length - p.length + 1; i++) {
    const subStr = s.slice(i, i + p.length)
    if (sortStr(subStr) === sp) {
      res.push(i)
    }
  }
  return res
};
function sortStr(str: string): string {
  const s = str.split('').sort().join('')
  return s
}
// 啊哦，又超时了，看来需要优化一下了，怎么优化呢？
// 1. 使用一个数组来存储p中每个字符出现的次数，然后遍历s，每次遍历都更新这个数组，然后判断这个数组是否和p中每个字符出现的次数相同，如果相同，则说明找到了一个字母异位词，将其下标加入结果数组中。
// 2. 使用滑动窗口来优化，每次遍历s时，只需要更新窗口中的字符出现的次数，然后判断窗口中的字符出现的次数是否和p中每个字符出现的次数相同，如果相同，则说明找到了一个字母异位词，将其下标加入结果数组中。
// 3. 使用哈希表来优化，每次遍历s时，只需要更新窗口中的字符出现的次数，然后判断窗口中的字符出现的次数是否和p中每个字符出现的次数相同，如果相同，则说明找到了一个字母异位词，将其下标加入结果数组中。
// 4. 使用双指针来优化，每次遍历s时，只需要更新窗口中的字符出现的次数，然后判断窗口中的字符出现的次数是否和p中每个字符出现的次数相同，如果相同，则说明找到了一个字母异位词，将其下标加入结果数组中。
// 5. 使用字典树来优化，每次遍历s时，只需要更新窗口中的字符出现的次数，然后判断窗口中的字符出现的次数是否和p中每个字符出现的次数相同，如果相同，则说明找到了一个字母异位词，将其下标加入结果数组中。
// 6. 使用前缀树来优化，每次遍历s时，只需要更新窗口中的字符出现的次数，然后判断窗口中的字符出现的次数是否和p中每个字符出现的次数相同，如果相同，则说明找到了一个字母异位词，将其下标加入结果数组中。
// 7. 使用后缀树来优化，每次遍历s时，只需要更新窗口中的字符出现的次数，然后判断窗口中的字符出现的次数是否和p中每个字符出现的次数相同，如果相同，则说明找到了一个字母异位词，将其下标加入结果数组中。
// 8. 使用后缀数组来优化，每次遍历s时，只需要更新窗口中的字符出现的次数，然后判断窗口中的字符出现的次数是否和p中每个字符出现的次数相同，如果相同，则说明找到了一个字母异位词，将其下标加入结果数组中。
// 9. 使用后缀自动机来优化，每次遍历s时，只需要更新窗口中的字符出现的次数，然后判断窗口中的字符出现的次数是否和p中每个字符出现的次数相同，如果相同，则说明找到了一个字母异位词，将其下标加入结果数组中。
// 10. 使用后缀平衡树来优化，每次遍历s时，只需要更新窗口中的字符出现的次数，然后判断窗口中的字符出现的次数是否和p中每个字符出现的次数相同，如果相同，则说明找到了一个字母异位词，将其下标加入结果数组中。
// 11. 使用后缀线段树来优化，每次遍历s时，只需要更新窗口中的字符出现的次数，然后判断窗口中的字符出现的次数是否和p中每个字符出现的次数相同，如果相同，则说明找到了一个字母异位词，将其下标加入结果数组中。
// 12. 使用后缀树状数组来优化，每次遍历s时，只需要更新窗口中的字符出现的次数，然后判断窗口中的字符出现的次数是否和p中每个字符出现的次数相同，如果相同，则说明找到了一个字母异位词，将其下标加入结果数组中。
// 13. 使用后缀线段树状数组来优化，每次遍历s时，只需要更新窗口中的字符出现的次数，然后判断窗口中的字符出现的次数是否和p中每个字符出现的次数相同，如果相同，则说明找到了一个字母异位词，将其下标加入结果数组中。
// 14. 使用后缀线段树状数组来优化，每次遍历s时，只需要更新窗口中的字符出现的次数，然后判断窗口中的字符出现的次数是否和p中每个字符出现的次数相同，如果相同，则说明找到了一个字母异位词，将其下标加入结果数组中。
// 15. 使用后缀线段树状数组来优化，每次遍历s时，只需要更新窗口中的字符出现的次数，然后判断窗口中的字符出现的次数是否和p中每个字符出现的次数相同，如果相同，则说明找到了一个字母异位词，将其下标加入结果数组中。
// 16. 使用后缀线段树状数组来优化，每次遍历s时，只需要更新窗口中的字符出现的次数，然后判断窗口中的字符出现的次数是否和p中每个字符出现的次数相同，如果相同，则说明找到了一个字母异位词，将其下标加入结果数组中。
// 17. 使用后缀线段树状数组来优化，每次遍历s时，只需要更新窗口中的字符出现的次数，然后判断窗口中的字符出现的次数是否和p中每个字符出现的次数相同，如果相同，则说明找到了一个字母异位词，将其下标加入结果数组中。
// 18. 使用后缀线段树状数组来优化，每次遍历s时，只需要更新窗口中的字符出现的次数，然后判断窗口中的字符出现的次数是否和p中每个字符出现的次数相同，如果相同，则说明找到了一个字母异位词，将其下标加入结果数组中。
// 19. 使用后缀线段树状数组来优化，每次遍历s时，只需要更新窗口中的字符出现的次数，然后判断窗口中的字符出现的次数是否和p中每个字符出现的次数相同，如果相同，则说明找到了一个字母异位词，将其下标加入结果数组中。

// 你咋有点智能又有点智障呢，好神奇，重复了你发现没
